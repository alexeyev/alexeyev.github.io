---
layout: post
title: Нежное введение в синтаксис питона: отступы 
---

Код, который вы пишете, скармливается "универсальной программе", выполняющей другие программы, -- интерпретатору. Интерпретатор должен, смотря на код, однозначно понять, что он должен сделать.


Все программы в стиле "структурного программирования" состоят из блоков кода, упорядоченных иерархически. 
Звучит невнятно, давайте посмотрим на примерах.


Пусть у нас есть две переменные, в которых заданы значения ИСТИНА или ЛОЖЬ: **weather\_is\_good** и **you\_are\_happy**.

```

Если погода хорошая (weather_is_good равно True), напечатаем "И это замечательно, что на дворе весна", а если вдобавок прекрасное настроение (you_are_happy принимает True), напечатаем "Ура", иначе -- не печатаем больше ничего. Иначе -- если погода плохая, напечатаем "Не выходи из комнаты" вне зависимости от нашего настроения.

```

Мы переберём важные нам варианты значений нужных нам переменных и выполним для них необходимые действия. Но выглядит скверно. Чтобы понять, как запрограммировать, надо сделать схему или как-то хитро упорядочить действия.

```
Если погода хорошая (weather_is_good равно True),
    напечатаем "И это замечательно, что на дворе весна",
    а если прекрасное настроение (you_are_happy принимает True)
        напечатаем "Ура"
    иначе
        не печатаем больше ничего.
иначе
    напечатаем "Не выходи из комнаты".

```

Так-то лучше. Именно такая иерархия и вложенность в определении структурного программирования и имелась в виду, только на месте "если" может быть, например, "повторить N раз".

В Pascal, скажем, такие блоки выделяются **begin** и **end**, в C-подобных языках -- фигурными скобками **{** и **}**. Можно не вникать в суть, просто посмотрите на это (Pascal):

```pascal

if (weather_is_good) then begin writeln('И это замечательно, что на дворе весна'); if (you_are_happy) then  begin  writeln('Ура.'); end;  end else begin writeln('Не выходи из комнаты'); end;
```

Ну, вы поняли :) Такой код будет работать, однако, во всех языках (кроме нескольких так называемых [эзотерических](https://ru.wikipedia.org/wiki/%D0%AD%D0%B7%D0%BE%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) хорошим тоном считается форматирование кода так, чтобы "зависимые" блоки
отделялись отступами от своих "базовых", например:

```pascal

if (weather_is_good) then
begin
    { первый уровень }
    writeln('И это замечательно, что на дворе весна');
    if (you_are_happy) then
    begin
        { второй уровень  }
        writeln('Ура.');
    end;
end
else
begin
    { первый уровень }
    writeln('Не выходи из комнаты')
end;

```

Но вернёмся к питону. Python суров, в нём такие блоки **должны** отделяться отступами, иначе интерпретатор не поймёт, что вы от него хотите; чем больше глубина иерархии, "вложенности", тем больше отступов.

Да -- раз об этом задают вопросы -- никаких **begin**, **end**, фигурных скобок и точек с запятыми в питоне нет!

Наш алгоритм можно записать так:

```python
if weather_is_good:
    print("И это замечательно, что на дворе весна")
    if you_are_happy:
        print("Ура")
    # иначе ничего не делаем
else:
    print("Не выходи из комнаты")
```

Попробуйте поперебирать разные значения наших переменных (всего, очевидно, четыре варианта). 

```python
weather_is_good = True # или False
you_are_happy = False # или True
```

А теперь можете запустить с разными вариантами значений переменных вот такой код

```python
if weather_is_good:
    print("И это замечательно, что на дворе весна")

if you_are_happy:
    print("Ура")
else:
    print("Не выходи из комнаты")
```

Поведение иное. Потому что здесь мы на самом деле написали:

```
Если погода хорошая (weather_is_good равно True),
    напечатаем "И это замечательно, что на дворе весна",
Иначе
    не печатаем ничего

Если прекрасное настроение (you_are_happy принимает True)
    напечатаем "Ура"
иначе
    напечатаем "Не выходи из комнаты".
```

То же верно не только для if, но и для других операторов.

Распечатайте, что происходит здесь:

```python
for i in range(3):
    print(i)
    for j in range(5):
        print(j)
```

а потом здесь:

```python    
for i in range(3):
    print(i)
    
for j in range(5):
    print(j)
```

Ясно, откуда разница в выводе?
