---
layout: default
---
<header class="masthead">        
  <h1 class="masthead-title">
    <a href="{{ site.baseurl }}/python-indents">Отступы в питоне</a>
  </h1>
  <nav class="masthead-nav">
    {% for nav in site.nav %}
      <a href="{{ nav.href }}">{{ nav.name }}</a>
    {% endfor %}
  </nav>
</header>

<pre>
Нежное введение в синтаксис питона: отступы 

Код, который вы пишете, скармливается "универсальной программе", выполняющей другие программы,
 -- интерпретатору. Интерпретатор должен, смотря на код, однозначно понять, что он должен сделать.

Все программы в стиле "структурного программирования" состоят из блоков кода, упорядоченных иерархически. Звучит невнятно, давайте посмотрим на примерах.

Пусть у нас есть две переменные, в которых заданы значения ИСТИНА или ЛОЖЬ: weather_is_good и you_are_happy.

Если погода хорошая (weather_is_good равно True), напечатаем "И это замечательно, что на дворе весна", а если вдобавок прекрасное настроение (you_are_happy принимает True), напечатаем "Ура", иначе -- не печатаем больше ничего. Иначе -- если погода плохая, напечатаем "Не выходи из комнаты" вне зависимости от нашего настроения.

Мы переберём важные нам варианты значений нужных нам переменных и выполним для них необходимые действия. Но выглядит скверно, чтобы понять, надо сделать схему или как-то хитро упорядочить действия.

Если погода хорошая (weather_is_good равно True),
    напечатаем "И это замечательно, что на дворе весна",
    а если прекрасное настроение (you_are_happy принимает True)
        напечатаем "Ура"
    иначе
        не печатаем больше ничего.
иначе
    напечатаем "Не выходи из комнаты".

Так-то лучше.
Именно такая иерархия и вложенность в определении структурного программирования и имелась в виду, только на месте "если" может быть, например, "повторить N раз".

В Pascal, скажем, такие блоки выделяются begin и end, в C-подобных языках -- фигурными скобками { и }.

if (weather_is_good) then begin writeln("И это замечательно, что на дворе весна"); if (you_are_happy) then  begin  writeln("Ура."); end;  end else begin writeln("Не выходи из комнаты"); end;

Ха-ха, ну вы поняли. В этих языках хорошим тоном считается форматирование кода так, чтобы "более зависимые" блоки
отделялись отступами, например:

if (weather_is_good) then
begin
    { первый уровень вложенности }
    writeln("И это замечательно, что на дворе весна");
    if (you_are_happy) then
    begin
        { второй уровень вложенности }
        writeln("Ура.");
    end;
end
else
begin
    { первый уровень вложенности }
    writeln("Не выходи из комнаты")
end;

Но вернёмся к питону. Python суров, в нём такие блоки ДОЛЖНЫ отделяться отступами, иначе интерпретатор не поймёт, что вы от него хотите; чем больше глубина иерархии, тем больше отступов.

if weather_is_good:
    print("И это замечательно, что на дворе весна")
    if you_are_happy:
        print("Ура")
else:
    print("Не выходи из комнаты")

Попробуйте поперебирать разные значения наших переменных (всего, очевидно, четыре варианта). 

weather_is_good = True
you_are_happy = False

А теперь вот такой код

if weather_is_good:
    print("И это замечательно, что на дворе весна")

if you_are_happy:
    print("Ура")
else:
    print("Не выходи из комнаты")

Поведение иное. Потому что здесь мы на самом деле написали:

Если погода хорошая (weather_is_good равно True),
    напечатаем "И это замечательно, что на дворе весна",
Иначе
    не печатаем ничего

Если прекрасное настроение (you_are_happy принимает True)
    напечатаем "Ура"
иначе
    напечатаем "Не выходи из комнаты".

То же верно не только для if, но и для других операторов.

Распечатайте, что происходит здесь:

for i in range(3):
    print(i)
    for j in range(5):
        print(j)

а потом здесь:

for i in range(3):
    print(i)

for j in range(5):
    print(j)

Ясно, откуда разница в выводе?
</pre>
